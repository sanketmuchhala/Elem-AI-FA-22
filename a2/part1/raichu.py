#
# raichu.py : Play the game of Raichu
#
# Code by: Abhiram Kukkapali, Sanket Muchhala, Haloran Riley 
#
# Based on skeleton code by D. Crandall, Oct 2021
#


# -*- coding: utf-8 -*-
"""Elements of AI HW2 Part 1.ipynb
Automatically generated by Colaboratory.
Original file is located at
    https://colab.research.google.com/drive/1wTFIf8sgGtd310p-T0mEnYKRsK9mNZyV
"""

#
# raichu.py : Play the game of Raichu
#
# Code by: Abhiram Kukkapali, Sanket Muchhala, Haloran Riley 
#
# Based on skeleton code by D. Crandall, Oct 2021
#


# -*- coding: utf-8 -*-
"""Elements of AI HW2 Part 1.ipynb
Automatically generated by Colaboratory.
Original file is located at
    https://colab.research.google.com/drive/1wTFIf8sgGtd310p-T0mEnYKRsK9mNZyV
"""

import sys
import time
import copy
import math
import random

max_depth=[1]
best_move_at_level={}
successor_table={}
max_player=""
infinity=9999
def board_to_string(board, N):
    return "\n".join(board[i:i+N] for i in range(0, len(board), N))

#Util func to swap characters at https://www.knowprogram.com/python/python-swap-characters-string/
def swap(str, i, j):
    list1 = list(str)
    list1[i], list1[j] = list1[j], list1[i]
    return ''.join(list1)

def remove(str, i):
    ls = list(str)
    ls[i] = "."
    return ''.join(ls)

def replace_raichu(str, i, color):
    ls = list(str)
    if(color == "w"):
        ls[i] = "@"
    elif(color == "b"):
        ls[i] = "$"
    return ''.join(ls)

def move_pichu(pos, N, board, color):
  list_of_boards = []
  pichu = ""

  #assign the player color
  if(color=="w"): #white
    pichu = "b"

    #check left
    if(pos%N != 0 and pos+N-1 < N*N): #no remainder means on the left side and not out of bounds
      if(board[pos+N-1]=="."): #spot is empty 
        ##print("left side move")
        boardCopy = copy.deepcopy(board)
        if(N*N-N <= pos+N-1): 
          ##print("reach end of board")
          boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu

        list_of_boards.append(swap(boardCopy, pos, pos+N-1)) #move the piece and add to list
      
      #left side take
      elif(board[pos+N-1]==pichu and (pos+N-1)%N !=0 and pos+(N*2)-2 < N*N): #spot has a pichu and next left isnt out of bounds and not below board
        if(board[pos+(N*2)-2]=="."): #spot is open 
          ##print("left side take")
          boardCopy = copy.deepcopy(board)
          if(N*N-N <=  pos+(N*2)-2): 
            ##print("reach end of board")
            boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu
          boardCopy = remove(boardCopy, pos+N-1) #remove the piece
          list_of_boards.append(swap(boardCopy, pos, pos+(N*2)-2))
    
    #right side
    if((pos+1)%N != 0 and pos+N+1 < N*N): #no remainder means on the right side and not out of bounds
      if(board[pos+N+1]=="."): #spot is empty 
        ##print("right side move")
        boardCopy = copy.deepcopy(board) #make a copy
        if(N*N-N <= pos+N+1): #check if on the bottom row
          ##print("reach end of board")
          boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu

        list_of_boards.append(swap(boardCopy, pos, pos+N+1)) #move the piece and add to list

      #right side take
      elif(board[pos+N+1]==pichu and (pos+N+1)%N !=0 and pos+(N*2)+2 < N*N): #spot has a pichu and next left isnt out of bounds and not below board
        if(board[pos+(N*2)+2]=="."): #spot is open 
          ##print("right side take")
          boardCopy = copy.deepcopy(board)
          if(N*N-N <= pos+(N*2)+2): #check if on the bottom row
            ##print("reach end of board")
            boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu
          boardCopy = remove(boardCopy, pos+N+1) #remove the piece
          list_of_boards.append(swap(boardCopy, pos, pos+(N*2)+2)) #move the piece and add to list


  elif(color=="b"): #black
    pichu="w"
  
    #check left
    if(pos%N!=0 and pos-N-1 >= 0): #no remainder means on the left side and not above the top
      if(board[pos-N-1]=="."): #spot is empty
        ##print("left side move")
        boardCopy = copy.deepcopy(board)
        if(N > pos-N-1): 
          ##print("reach end of board")
          boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu
        list_of_boards.append(swap(boardCopy, pos, pos-N-1)) #move the piece and add to list
      
      #left side take
      elif(board[pos-N-1]==pichu and (pos-N-1)%N !=0 and pos-N*2-2 >= 0): #spot has a pichu
        if(board[pos-(N*2)-2]=="."): #spot is open
          ##print("left side take")
          boardCopy = copy.deepcopy(board)
          if(N > pos-N*2-2): 
            ##print("reach end of board")
            boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu
          boardCopy = remove(boardCopy, pos-N-1) #remove the piece
          list_of_boards.append(swap(boardCopy, pos, pos-N*2-2))
    
    #right side
    if((pos+1)%N != 0 and pos-N+1 >= 0): #no remainder means on the right side and not above the top
      if(board[pos-N+1]=="."): #spot is open
        ##print("right side move")
        boardCopy = copy.deepcopy(board)
        if(N > pos-N+1): 
          ##print("reach end of board")
          boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu
        list_of_boards.append(swap(boardCopy, pos, pos-N+1))
      
      #right side take
      elif(board[pos-N+1]==pichu and (pos-N+1)%N !=0 and pos-N*2+2 >= 0): #spot has a pichu
        if(board[pos-(N*2)+2]=="."): #spot is open
          ##print("right side take")
          boardCopy = copy.deepcopy(board)
          if(N > pos-N*2+2): 
            ##print("reach end of board")
            boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu
          boardCopy = remove(boardCopy, pos-N+1) #remove the piece
          list_of_boards.append(swap(boardCopy, pos, pos-N*2+2)) #move the piece and add to list
 
  return list_of_boards

def move_pikachu(pos, N, board, color):
  list_of_boards = []
  pichu = ""
  pikachu = ""

  #assign the player color
  if(color=="w"):
    pichu = "b"
    pikachu = "B"

    ##print(pichu + " " + pikachu)

    ##print("White")

    #GO LEFT
    if(pos%N != 0):
      if(board[pos-1]=="."): #MOVE ONE to the left
        ##print("left side move 1")
        boardCopy = copy.deepcopy(board)
        list_of_boards.append(swap(boardCopy, pos, pos-1)) #move the piece and add to list

        if((pos-1)%N != 0): #if the next spot is not the edge
          if(board[pos-2]=="."): #MOVE TWO to the left
            ##print("left side move 2")
            boardCopy = copy.deepcopy(board)
            list_of_boards.append(swap(boardCopy, pos, pos-2)) #move the piece and add to list

          elif((board[pos-2]==pichu) or ((board[pos-2]==pikachu)) and (pos-2)%N != 0): #there is an enemy and no wrap around
            if(board[pos-3]=="."): #Move 3 to the left
              ##print("left side take 2")
              boardCopy = copy.deepcopy(board)
              boardCopy = remove(boardCopy, pos-2) #remove the piece
              list_of_boards.append(swap(boardCopy, pos, pos-3)) #move the piece and add to list

      elif(((board[pos-1]==pichu) or (board[pos-1]==pikachu)) and (pos-1)%N != 0): #there is an enemy and no wrap around
        if(board[pos-2]=="."): #Move 2 to the left
          ##print("left side take 1")
          boardCopy = copy.deepcopy(board)
          boardCopy = remove(boardCopy, pos-1) #remove the piece
          list_of_boards.append(swap(boardCopy, pos, pos-2)) #move the piece and add to list
    
    #GO RIGHT
    if((pos+1)%N != 0):
      if(board[pos+1]=="."): #MOVE ONE to the right
        ##print("right side move ")
        boardCopy = copy.deepcopy(board)
        list_of_boards.append(swap(boardCopy, pos, pos+1)) #move the piece and add to list

        if((pos+2)%N != 0): #if the next spot is not the edge
          if(board[pos+2]=="."): #MOVE TWO to the right
            ##print("right side move 2")
            boardCopy = copy.deepcopy(board)
            list_of_boards.append(swap(boardCopy, pos, pos+2)) #move the piece and add to list

          elif(((board[pos+2]==pichu) or (board[pos+2]==pikachu)) and (pos+3)%N != 0): #there is an enemy and no wrap around
            if(board[pos+3]=="."): #Move 3 to the left
              ##print("right side take 2")
              boardCopy = copy.deepcopy(board)
              boardCopy = remove(boardCopy, pos+2) #remove the piece
              list_of_boards.append(swap(boardCopy, pos, pos+3)) #move the piece and add to list

      elif(((board[pos+1]==pichu) or (board[pos+1]==pikachu)) and (pos+2)%N != 0): #there is an enemy and no wrap around
        if(board[pos+2]=="."): #Move 2 to the left
          ##print("right side take 1")
          boardCopy = copy.deepcopy(board)
          boardCopy = remove(boardCopy, pos+1) #remove the piece
          list_of_boards.append(swap(boardCopy, pos, pos+2)) #move the piece and add to list


    #GO FORWARD
    if(pos+N < N*N):
      if(board[pos+N]=="."):
        ##print("forward move 1")
        boardCopy = copy.deepcopy(board)
        if(N*N-N <= pos+N): #check if on the bottom row
          ##print("reach end of board")
          boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu
        list_of_boards.append(swap(boardCopy, pos, pos+N)) #move the piece and add to list

        if(pos+N+N < N*N): #check the forward spot for out of bounds so no string out of range error
          if(board[pos+N+N]=="."): #Forward 2
            ##print("forward move 2")
            boardCopy = copy.deepcopy(board)
            if(N*N-N <= pos+N+N): #check if on the bottom row
              ##print("reach end of board")
              boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu
            list_of_boards.append(swap(boardCopy, pos, pos+N+N)) #move the piece and add to list
            
          elif(((board[pos+N+N]==pichu) or (board[pos+N+N]==pikachu)) and pos+N+N+N < N*N): #Forward 2 take
            if(board[pos+N+N+N]=="."):
              ##print("forward take 2")
              boardCopy = copy.deepcopy(board)
              if(N*N-N <= pos+N+N+N): #check if on the bottom row
                ##print("reach end of board")
                boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu
              boardCopy = remove(boardCopy, pos+N+N) #remove the piece
              list_of_boards.append(swap(boardCopy, pos, pos+N+N+N)) #move the piece and add to list

        elif(((board[pos+N]==pichu) or (board[pos+N]==pikachu)) and pos+N+N < N*N): #1st forward take
          if(board[pos+N+N]=="."):
            ##print("forward take 1")
            boardCopy = copy.deepcopy(board)
            if(N*N-N <= pos+N+N): #check if on the bottom row
              ##print("reach end of board")
              boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu
            boardCopy = remove(boardCopy, pos+N) #remove the piece
            list_of_boards.append(swap(boardCopy, pos, pos+N+N)) #move the piece and add to list


  #assign the player color
  elif(color=="b"):
    pichu = "w"
    pikachu = "W"

    ##print("Black")

    #GO LEFT
    if(pos%N != 0):
      if(board[pos-1]=="."): #MOVE ONE to the left
        ##print("left side move 1")
        boardCopy = copy.deepcopy(board)
        list_of_boards.append(swap(boardCopy, pos, pos-1)) #move the piece and add to list

        if((pos-1)%N != 0): #if the next spot is not the edge
          if(board[pos-2]=="."): #MOVE TWO to the left
            ##print("left side move 2")
            boardCopy = copy.deepcopy(board)
            list_of_boards.append(swap(boardCopy, pos, pos-2)) #move the piece and add to list

          elif(((board[pos-2]==pichu) or (board[pos-2]==pikachu)) and (pos-2)%N != 0): #there is an enemy and no wrap around
            if(board[pos-3]=="."): #Move 3 to the left
              ##print("left side take 2")
              boardCopy = copy.deepcopy(board)
              boardCopy = remove(boardCopy, pos-2) #remove the piece
              list_of_boards.append(swap(boardCopy, pos, pos-3)) #move the piece and add to list

      elif(((board[pos-1]==pichu) or (board[pos-1]==pikachu)) and (pos-1)%N != 0): #there is an enemy and no wrap around
        if(board[pos-2]=="."): #Move 2 to the left
          ##print("left side take 1")
          boardCopy = copy.deepcopy(board)
          boardCopy = remove(boardCopy, pos-1) #remove the piece
          list_of_boards.append(swap(boardCopy, pos, pos-2)) #move the piece and add to list
    
    #GO RIGHT
    if((pos+1)%N != 0):
      if(board[pos+1]=="."): #MOVE ONE to the right
        ##print("right side move 1")
        boardCopy = copy.deepcopy(board)
        list_of_boards.append(swap(boardCopy, pos, pos+1)) #move the piece and add to list

        if((pos+2)%N != 0): #if the next spot is not the edge
          if(board[pos+2]=="."): #MOVE TWO to the right
            ##print("right side move 2")
            boardCopy = copy.deepcopy(board)
            list_of_boards.append(swap(boardCopy, pos, pos+2)) #move the piece and add to list

          elif(((board[pos+2]==pichu) or (board[pos+2]==pikachu)) and (pos+3)%N != 0): #there is an enemy and no wrap around
            if(board[pos+3]=="."): #Move 3 to the left
              ##print("right side take 2")
              boardCopy = copy.deepcopy(board)
              boardCopy = remove(boardCopy, pos+2) #remove the piece
              list_of_boards.append(swap(boardCopy, pos, pos+3)) #move the piece and add to list

      elif((board[pos+1]==pichu) or (board[pos+1]==pikachu) and (pos+1)%N != 0): #there is an enemy and no wrap around
        if(board[pos+2]=="."): #Move 2 to the left
          ##print("right side take 1")
          boardCopy = copy.deepcopy(board)
          boardCopy = remove(boardCopy, pos+1) #remove the piece
          list_of_boards.append(swap(boardCopy, pos, pos+2)) #move the piece and add to list


    #GO FORWARD
    if(pos-N >= 0):
      if(board[pos-N]=="."):
        ##print("forward move 1")
        boardCopy = copy.deepcopy(board)
        if(N > pos-N): #check if on the bottom row
            ##print("reach end of board")
            boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu
        list_of_boards.append(swap(boardCopy, pos, pos-N)) #move the piece and add to list

        if(pos-N-N >= 0): #check the forward spot for out of bounds so no string out of range error
          if(board[pos-N-N]=="."): #Forward 2
            ##print("forward move 2")
            boardCopy = copy.deepcopy(board)
            if(N > pos-N-N): #check if on the bottom row
              ##print("reach end of board")
              boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu
            list_of_boards.append(swap(boardCopy, pos, pos-N-N)) #move the piece and add to list
            
          elif(((board[pos-N-N]==pichu) or (board[pos-N-N]==pikachu)) and pos-N-N-N >= 0): #Forward 2 take
            if(board[pos-N-N-N]=="."): #Forward 3
              ##print("forward take 2")
              boardCopy = copy.deepcopy(board)
              if(N > pos-N-N-N): #check if on the bottom row
                ##print("reach end of board")
                boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu
              boardCopy = remove(boardCopy, pos-N-N) #remove the piece
              list_of_boards.append(swap(boardCopy, pos, pos-N-N-N)) #move the piece and add to list

        elif(((board[pos+N] == pichu) or (board[pos+N] == pikachu)) and pos+N+N >= 0): #1st forward take
          if(board[pos+N+N]=="."): #Forward 2
            ##print("forward take 1")
            boardCopy = copy.deepcopy(board)
            if(N > pos+N+N): #check if on the bottom row
              ##print("reach end of board")
              boardCopy = replace_raichu(boardCopy, pos, color) #replace with raichu
            boardCopy = remove(boardCopy, pos+N) #remove the piece
            list_of_boards.append(swap(boardCopy, pos, pos+N+N)) #move the piece and add to list

  return list_of_boards

def move_raichu(pos, N, board, color):
  list_of_boards = []
  pichu = ""
  pikachu = ""
  raichu = ""

  if (color=="w"):
    #print("White")
    pichu = "b"
    pikachu = "B"
    raichu = "$"
  elif(color=="b"):
    #print("black")
    pichu = "w"
    pikachu = "W"
    raichu = "@"

  #up
  piece_taken = False
  tempPos = pos - N
  tempBoard = copy.deepcopy(board)

  while(tempPos >= 0):
    if(board[tempPos]=="."):
      boardCopy = copy.deepcopy(tempBoard)
      list_of_boards.append(swap(boardCopy, pos, tempPos)) #move the piece and add to list
      tempPos-=N #move the temp pos up
    elif((board[tempPos] == pichu) or (board[tempPos] == pikachu) or (board[tempPos] == raichu)): #if we hit an enemy piece
      if(piece_taken): #stop if weve already taken a piece
        break
      else:
        tempBoard = remove(tempBoard, tempPos) #remove the piece from the temp board so the next moves dont have the piece
        piece_taken = True
        tempPos-=N #move the temp pos up
    else: #if we hit a different piece its an ally so just break
      break 

  #down
  piece_taken = False
  tempPos = pos + N
  tempBoard = copy.deepcopy(board)

  while(tempPos < N*N):
    if(board[tempPos]=="."):
      #print("piece moving down")
      boardCopy = copy.deepcopy(tempBoard)
      list_of_boards.append(swap(boardCopy, pos, tempPos)) #move the piece and add to list
      tempPos+=N #move the temp pos down
    elif((board[tempPos] == pichu) or (board[tempPos] == pikachu) or (board[tempPos] == raichu)): #if we hit an enemy piece
      if(piece_taken): #stop if weve already taken a piece
        break
      else:
        #print("piece taken going down")
        tempBoard = remove(tempBoard, tempPos) #remove the piece from the temp board so the next moves dont have the piece
        piece_taken = True
        tempPos+=N #move the temp pos down
    else: #if we hit a different piece its an ally so just break
      #print("reached an ally piece")
      break 

  #left
  piece_taken = False
  tempPos = pos -1
  tempBoard = copy.deepcopy(board)

  while((tempPos+1)%N != 0):
    if(board[tempPos]=="."):
      #print("piece moving down")
      boardCopy = copy.deepcopy(tempBoard)
      list_of_boards.append(swap(boardCopy, pos, tempPos)) #move the piece and add to list
      tempPos-=1 #move the temp pos down
    elif((board[tempPos] == pichu) or (board[tempPos] == pikachu) or (board[tempPos] == raichu)): #if we hit an enemy piece
      if(piece_taken): #stop if weve already taken a piece
        break
      else:
        #print("piece taken going down")
        tempBoard = remove(tempBoard, tempPos) #remove the piece from the temp board so the next moves dont have the piece
        piece_taken = True
        tempPos-=1 #move the temp pos down
    else: #if we hit a different piece its an ally so just break
      #print("reached an ally piece")
      break 


  #right
  piece_taken = False
  tempPos = pos + 1
  tempBoard = copy.deepcopy(board)

  while(tempPos%N != 0):
    if(board[tempPos]=="."):
      #print("piece moving down")
      boardCopy = copy.deepcopy(tempBoard)
      list_of_boards.append(swap(boardCopy, pos, tempPos)) #move the piece and add to list
      tempPos+=1 #move the temp pos down
    elif((board[tempPos] == pichu) or (board[tempPos] == pikachu) or (board[tempPos] == raichu)): #if we hit an enemy piece
      if(piece_taken): #stop if weve already taken a piece
        break
      else:
        #print("piece taken going down")
        tempBoard = remove(tempBoard, tempPos) #remove the piece from the temp board so the next moves dont have the piece
        piece_taken = True
        tempPos+=1 #move the temp pos down
    else: #if we hit a different piece its an ally so just break
      #print("reached an ally piece")
      break 


  #Diagnal right up
  piece_taken = False
  tempPos = pos + 1 - N
  tempBoard = copy.deepcopy(board)

  while(tempPos%N != 0 and tempPos >= 0):
    if(board[tempPos]=="."):
      #print("piece moving diagnal right up")
      boardCopy = copy.deepcopy(tempBoard)
      list_of_boards.append(swap(boardCopy, pos, tempPos)) #move the piece and add to list
      tempPos = tempPos + 1 - N #move the temp pos down
    elif((board[tempPos] == pichu) or (board[tempPos] == pikachu) or (board[tempPos] == raichu)): #if we hit an enemy piece
      if(piece_taken): #stop if weve already taken a piece
        break
      else:
        #print("piece taken going diagnal right up")
        tempBoard = remove(tempBoard, tempPos) #remove the piece from the temp board so the next moves dont have the piece
        piece_taken = True
        tempPos = tempPos + 1 - N #move the temp pos down
    else: #if we hit a different piece its an ally so just break
      #print("reached an ally piece")
      break 


  #diagnal left up
  piece_taken = False
  tempPos = pos - 1 - N
  tempBoard = copy.deepcopy(board)

  while((tempPos+1)%N != 0 and tempPos >=0):
    if(board[tempPos]=="."):
      #print("piece moving diagnal left up")
      boardCopy = copy.deepcopy(tempBoard)
      list_of_boards.append(swap(boardCopy, pos, tempPos)) #move the piece and add to list
      tempPos = tempPos - 1 - N #move the temp pos down
    elif((board[tempPos] == pichu) or (board[tempPos] == pikachu) or (board[tempPos] == raichu)): #if we hit an enemy piece
      if(piece_taken): #stop if weve already taken a piece
        break
      else:
        #print("piece taken going diagnal left up")
        tempBoard = remove(tempBoard, tempPos) #remove the piece from the temp board so the next moves dont have the piece
        piece_taken = True
        tempPos = tempPos - 1 - N #move the temp pos down
    else: #if we hit a different piece its an ally so just break
      #print("reached an ally piece")
      break 
  
  #diagnal right down
  piece_taken = False
  tempPos = pos + 1 + N
  tempBoard = copy.deepcopy(board)

  while(tempPos%N != 0 and tempPos < N*N):
    if(board[tempPos]=="."):
      #print("piece moving diagnal right down")
      boardCopy = copy.deepcopy(tempBoard)
      list_of_boards.append(swap(boardCopy, pos, tempPos)) #move the piece and add to list
      tempPos = tempPos + 1 + N #move the temp pos down
    elif((board[tempPos] == pichu) or (board[tempPos] == pikachu) or (board[tempPos] == raichu)): #if we hit an enemy piece
      if(piece_taken): #stop if weve already taken a piece
        break
      else:
        #print("piece taken going diagnal right down")
        tempBoard = remove(tempBoard, tempPos) #remove the piece from the temp board so the next moves dont have the piece
        piece_taken = True
        tempPos = tempPos + 1 + N #move the temp pos down
    else: #if we hit a different piece its an ally so just break
      #print("reached an ally piece")
      break 
  
  #diagnal left down
  piece_taken = False
  tempPos = pos - 1 + N
  tempBoard = copy.deepcopy(board)

  while((tempPos+1)%N != 0 and tempPos < N*N):
    if(board[tempPos]=="."):
      #print("piece moving diagnal left down")
      boardCopy = copy.deepcopy(tempBoard)
      list_of_boards.append(swap(boardCopy, pos, tempPos)) #move the piece and add to list
      tempPos = tempPos - 1 + N #move the temp pos down
    elif((board[tempPos] == pichu) or (board[tempPos] == pikachu) or (board[tempPos] == raichu)): #if we hit an enemy piece
      if(piece_taken): #stop if weve already taken a piece
        break
      else:
        #print("piece taken going diagnal left down")
        tempBoard = remove(tempBoard, tempPos) #remove the piece from the temp board so the next moves dont have the piece
        piece_taken = True
        tempPos = tempPos - 1 + N #move the temp pos down
    else: #if we hit a different piece its an ally so just break
      #print("reached an ally piece")
      break 

  return list_of_boards

#test
#if("........W.B.W.b..w.w.w.w................b.b.b.b....B...B........"[8]=="." ):
    ##print("it works")

#functions that gets the fringe and 
def get_fringe(board, N, color):
    fringe = []
    for i in range(len(board)):
        if board[i] == "w" and color=="w":
            fringe += move_pichu(i, N, board, "w")
        elif board[i] == "b" and color=="b":
            fringe += move_pichu(i, N, board, "b")
        elif board[i] == "W" and color=="w":
            fringe += move_pikachu(i, N, board, "w")
        elif board[i] == "B" and color=="b":
            fringe += move_pikachu(i, N, board, "b")
        elif board[i] == "@" and color=="w":
            fringe += move_raichu(i, N, board, "w")
        elif board[i] == "$" and color=="b":
            fringe += move_raichu(i, N, board, "b")
    ##print(fringe)
    return fringe

def opponent(player):
    if player=="b":
        return "w"
    elif player=="w":
        return "b"
    
    
def is_goal(board):
    if(board.count("B")==0 and board.count("b")==0 and board.count("$")==0):
        return True
    if(board.count("W")==0 and board.count("w")==0 and board.count("@")==0):
        return True
    else:
        return False

def eval(board,player,N,ini_player):
    board=list(board)
    ##print(board)
    score=(board.count("w")*1)+(board.count("W")*3)+(board.count("@")*6)
    score1=(board.count("b")*1)+(board.count("B")*3)+(board.count("$")*6)
    if player==ini_player:
        return score-score1
    else:
        return -1*(score1-score)
#minmax algorithm
def minimax(board,N, depth, alpha, beta, player,player_bool,ini_player):
    s = get_fringe(board,N,player)
    if is_goal(board) or depth==0:
        return None,eval(board,player,N,ini_player)             
    next_move = random.choice(s)
    if player_bool==True:
        max_eval=-999999
        for i in get_fringe(board,N,player):
            score=minimax(i,N, depth - 1, alpha, beta,opponent(player), False,ini_player)[1]
            if score > max_eval:
                max_eval = score
                next_move = i 
            alpha=max(score, alpha)
            if alpha>=beta:
                break
        return next_move, max_eval
    if player_bool==False:
        min_eval=999999
        for i in get_fringe(board,N,player):
            score1=minimax(i,N, depth - 1, alpha, beta,opponent(player),True,ini_player)[1]
            if score1 < min_eval:
                min_eval = score1
                next_move = i
            beta=min(score1, alpha)
            if alpha>=beta:
                break
        return next_move, min_eval


    
def alpha_beta_decision(board, player,N,ini_player):
    maximum_value={}
    for s in get_fringe(board,N,player):
        v=min_val(s, opponent(player), -math.inf, math.inf, 0,N,ini_player)
        maximum_value[tuple(s)]=v
    a =max(maximum_value,key=maximum_value.get)
    return a

#Max-Value
def max_val(board, player, alpha, beta, depth,N,ini_player):
    if is_goal(board)or depth>max_depth[0]:
        return eval(board,player,N,ini_player)
    alpha_dash=-math.inf
    for s in get_fringe(board,N,player):
        score_of_s=min_val(s, opponent(player), alpha, beta, depth + 1,N,ini_player)
        alpha_dash=max(score_of_s, alpha_dash)
        if alpha_dash>=beta:
            return alpha_dash
    return alpha_dash

#Min-Value
def min_val(board, player, alpha, beta, depth,N,ini_player):
    if is_goal(board) or depth>max_depth[0]:
        return eval(board,player,N,ini_player)
    beta_dash=math.inf
    for s in get_fringe(board,N,player):
        score_of_s=max_val(s, opponent(player), alpha, beta, depth + 1,N,ini_player)
        beta_dash = min(score_of_s, beta_dash)
        if alpha>=beta_dash:
            return beta_dash
    return beta_dash


def find_best_move(board, N, player, timelimit):
    #board=list(board)
    ##print('yes")
    ini_player=player
    ls=random.choice(get_fringe(board,N,player))
    print(ls)
    for depth in range(2,5):
            max_depth[0]=depth
            recommended_board = alpha_beta_decision(board,player,N,ini_player)
            if is_goal(recommended_board):
                next_board = ''.join((item) for innerlist in recommended_board for item in innerlist)
                print(next_board)
                break
            next_board = ''.join((item) for innerlist in recommended_board for item in innerlist)
            print(next_board)
    return (next_board,next_board)



if __name__ == "__main__":
    if len(sys.argv) != 5:
        raise Exception("Usage: Raichu.py N player board timelimit")
        
    (_, N, player, board, timelimit) = sys.argv
    N=int(N)
    timelimit=int(timelimit)
    if player not in "wb":
        raise Exception("Invalid player.")

    if len(board) != N*N or 0 in [c in "wb.WB@$" for c in board]:
        raise Exception("Bad board string.")

    print("Searching for best move for " + player + " from board state: \n" + board_to_string(board, N))
    print("Here's what I decided:")
    for new_board in find_best_move(board, N, player, timelimit):
        print(new_board)
