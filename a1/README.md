# sakrathi-rifhall-samuch-a1
### report and analysis for part1,part2,part3.
Part1: Birds,Heuristics and A* Aim: To arrange the birds wearing in a ordered form that is 1,2..N. The birds are wearing any number between 1 TO N. At once, exactly one bird can change places with exactly one neighbouring birds.

Algorithm: A star is implemented. The evaluation function f(s) = g(s) + h(s) f(s) = g(s) + h(s) where g(s) is the cost of the path from the initial state to the current state. and h(s) is the best path cost from the current state to the goal state. Here, and g(s) is the cost of initial state to current state,so it can be taken as 1 everytime a bird interchanges it's position. h(s) is the number of misplaced numbers as compared to the goal state. Heuristic used: number of misplaced numbers when compared to the goal state. For every state, the successor function finds the next possible states and all the states are appended to the fringe,which is a priority queue, with the priority being the evaluation function for each state. The next state is decided on the basis of of the one with the max priority, least evaluation cost. And we check if the next state is the goal state, if yes, the path of traversal is returned. if no, the same process continues.

Part2: The Branching factor is 24 for this problem. At each step, the alg can rotate the 5 rows left and right (10), the 5 cols up and down (10), and rotate the outer and inner ring either cw or cc (4) so 24 branches in total at each step. If we are using BFS then that means at each state we are adding all children to the fringe. As a result we will can aproximate the max # of states by taking 24 to the power of 7. The total is is 24^7 which equals 4586471424 states to check.

Part3 Aim: fatest route from one city to another based on the cost defined. if the cost is distance, fastest route is defined as the one with minimum distance if the cost is segments, fastest route is defined as the one with least segments if the cost is time, fastest route is defined as the one with minimum time. if the cost is delivery, fastest route for a delivery driver, considering that if the speed>50mph there is a probability that the package might fall and this will only add up the time to troad + p Â·2(troad + ttrip), where ttrip is the time it took to get from the start city to the beginning of the road, and troad is the time it takes to drive the length of the road segment.

Algorithm: astar is implemented for finding the fastest route between 2 given cities. astar algorithm initiates a fringe which is a priority queue and the next possible states for a given state are found using a successor function, the states found are appended to the fringe with the priority being the evaluation function. The state with the most priority is popped and checked if it's a goal state and if not, the next possible states are found and so on. The initial state being the [start city, dist=0,speed=0,highway=NULL] the evaluation function is f(s) = g(s) + h(s) g(s): cost of initial state to the current state h(s) heuristic function

for cost=distance:Here,g(s) is the distance of the segment that we traverse through. h(s) is the haversine distance(calculates distance based on the latitude and longitude of the current state city to the end state city) of the current state to the goal state. 
for cost=segments: g(s) the the number of segments from the initial state to the current state. h(s) the possible number of segments from the current state to the end state. considering it to be the haversine, assuming the one with the minimum haversine distance will have minimum number of segments.
for cost=time: g(s) the number of hours from initial state to the current state,which is distance/speed, state[1] / state[2]
h(s) the possible no of hours from current state to the goal state, that is haversine distance(current state,goal state) / 50 mph , considering the avg speed as 50 mph
for cost=delivery: g(s) the number of hours from initial state to the current state, considering the possibility of the speed exceeding the speed limit and the package falling off, thus adding to extra time, which is troad + 2*p*(troad + ttrip) ttrip is the time it took to get from the start city to the beginning of the road,and troad is the time it takes to drive the length of the road segment.
thus, g(s) = g = g + 2*p*(g + state[1]/state[2]) , where l = state[1], l is the length of road segment and p = math.tanh(l / 1000)         
h(s) the best possible time being no over speeding thus taking it to be dist/speed = haversine dist (current state, goal state) / 50 mph
